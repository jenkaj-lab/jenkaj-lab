---
title: Detecting and Mitigating Active Directory LDAP Password Guessing Attacks with Wazuh
date: 2025-01-26
draft: false
author: Alex Jenkins
---
# Blue Team
## Assumptions
- Wazuh is configured and listening to AD logs

## Detection
1. Run the brute forcer script from the red teaming exercise
2. Navigate to Explore/Discover in Wazuh
3. Add a filter for 'data.win.eventdata.targetUserName: scarab'
4. Filter for the last hour

After running the ldap_brute_forcer.py script we can see from the logs that there are 9 authentication failures, and one success. This lines up perfectly with the rockyou.txt wordlist, and is showing exactly as expected. Digging into these failed logins further will unveil some key information which describes the failed login in more det the following key data can be extracted:

> data.win.eventdata.status: 0xc000006d  
data.win.eventdata.subStatus: 0xc000006a  
data.win.eventdata.targetUserName: scarab  
data.win.eventdata.ipAddress: 192.168.1.236  

This information is important because it describes login failures through the status and substatus codes. It gives information regarding the source IP address of the login failure and the account the logon was attempted for. Status code 0xc000006d is the generic code for a logon failure, stating the the attempted logon is invalid. Microsoft state that "this is either due to a bad username or other authentication information". 0xc000006a is a substatus code for 0xc000006d which elaborates on the authentication failure. This code explains that the value provided as the current password is not correct. One final important bit of information is the logon type. In this case the logon type is 3, which indicates that this is a network logon and not an interactive session.

![Failed Login](jenkaj-lab/assets/failed_login.png)

The 10th and final event resulting from the brute force script is a logoff event. This is a little strange because I was expecting a logon success, but this appears to be a caveat of ldapsearch and bind. When a bind is performed all it does is prove a user's identity, and there is no persistent "logged in" state. Instead, the ldapsearch command processes the search request and immediately closes the connection. To find out more about this event I grabbed the data.win.system.eventID, which is 4634 in this case, and looked it up in [Microsoft's documentation](learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/auditing/event-4634).

![Logoff](jenkaj-lab/assets/logoff.png)

To summarize: Event code 4634 shows that the logon session was terminated and no longer exists. This code differs from 4647, which is a logoff event initiated by a user directly. This non-user logoff may sometimes be correlated with 4624, which indicates a successful logon. In this case, however, there is no correlation to be found.

The new found information tells me that in future brute force cases I should be suspicious of failed logins followed by a terminated logon session. This is proven by the event logs generated by the LDAP brute forcer, which has managed to successfully guess password credentials, immediately terminating the logon session upon completion. Information like this is important because it can help differentiate a brute force attempt from a normal successful logon, where the user may have incorrectly entered their password before logging in. Another important indicator to consider for brute force attempts is the timestamp of each event. In this case, the difference in event timestamps are a matter of milliseconds. The frequency of login failures is far too high to be human error and is indicative of a computer-aided operation.

### Rule Creation
Now that we've gone through and manually detected the attack, we can grab our key data that we noted at the beginning and start to write some detection rules. These will alert us whenever this type of activity is seen again. In Wazuh, this can be done by navigating to the "Monitors" tab under Explore/Alerting, then clicking "Create monitor". I'll include screenshots of my configurations as we go with little explanations as to why I've made some of my decisions.

![Monitor Details](jenkaj-lab/assets/monitor_details.png)

Most of this is default with the exception of the frequency. Obviously this is up to you, but I like to be reminded every 30 minutes if a brute force is detected. My reasoning is that I want response time to be quick for a brute force detection, because any delay could lead to an account compromise. If you wait too long between alerts it could already be too late by the time it comes through. If you want it sooner for testing purposes you can run it every minute.

![Select Data](jenkaj-lab/assets/select_data.png)

Most of this is default, I've made the time field the timestamp because that just felt the most logical, and I've used the * wildcard for indexes to include them all.

![Query](jenkaj-lab/assets/query.png)

The query section is the fun part. I would recommend first setting the time range to the same as the time in your monitor details so that you don't get spammed with alerts. We're filtering for the status and substatus codes, and counting the number of substatus codes. This count will allow us to create a detection rule based on the number of login failures, grouped on the IP address. With the count setup you can make a trigger rule.

![Trigger Rule](jenkaj-lab/assets/trigger.png)

And there you go. The rule is setup. You can make an action if you want which will notify you whenever this alert is triggered, I like to have mine notify me on my phone through Slack, but that is outside the scope of this lab. Once you save this monitor an alert will be triggered every time 5 failures, grouped by IP address, are detected with the substatus 0xc000006a. Now run your script again to check to see if it works, you should see at least one alert (don't forget to wait the time you allocated to the monitor).

![Alerts](jenkaj-lab/assets/alert.png)

Great. That's the detection rule setup, but what about mitigation?

## Mitigation
So MITRE explains that there are 4 ways of mitigating this type of threat: 
```
- Account Use Policies  
Set account lockout policies after a certain number of failed login attempts to prevent passwords from being guessed. Too strict a policy may create a denial of service condition and render environments un-usable, with all accounts used in the brute force being locked-out. Use conditional access policies to block logins from non-compliant devices or from outside defined organization IP ranges. Consider blocking risky authentication requests, such as those originating from anonymizing services/proxies.

- Multi-Factor Authentication (MFA)  
Use multi-factor authentication. Where possible, also enable multi-factor authentication on externally facing services.

- Password Policies  
Refer to NIST guidelines when creating password policies.

- Update Software  
Upgrade management services to the latest supported and compatible version. Specifically, any version providing increased password complexity or policy enforcement preventing default or weak passwords.
```

The simplest seems to be password policies. Obviously for this practice we made the password policy intentionally weak, so the simple solution would be to increase password length and complexity. Other methods include enforcing MFA on accounts, which is always a good method and in my opinion should be mandatory for all users. Single-factor authentication methods are considered legacy authentication systems, and are inherently vulnerable to brute force attacks. Account lockout policies are another great method, locking the account and making it unusable if a threshold of failed login attempts is reached. This method can be inconvenient for the user if other mechanisms are not in place, as it could restrict access to their account. Other methods include restricting access to geographical zones, only allowing logins from specific IPs, or blocking IP addresses outright if found to be malicious. Whilst these last 3 methods do have their benefits, I will not be doing this because it will hinder future red team assessments.

Given my current constraints I will be enforcing account lockout. There are three reasons for this:

1. It is one of simplest methods of defence against brute force and will display some new event logs for research.
2. Changing the password policies would require a password change, requiring modifications to the brute force script. 
3. Adopting MFA in a local Active Directory environment requires the installation of a third-party client, which is honestly more hassle than its worth for a homelab.

To change the account lockout policy open the Group Policy Management Editor in Windows Server, and navigate to Computer Configuration/Policies/Windows Settings/Security Settings/Account Policies/Account Lockout Policy. I've configured mine to lockout the account for 30 minutes if more than 5 invalid logon attempts are made. The counter will reset after another 30 minutes. 

Now when the script is run it continues running beyond the correct password, never completing because the account gets locked before it can successfully authenticate. When looking at this in Wazuh an event can be found showing that the account was locked out with the [Event ID 4740](learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/auditing/event-4740).

![Account Lockout](jenkaj-lab/assets/account_lockout.png)

This event shows that the mitigation was successful, and that this method of brute force no longer works. Obviously this has limitations, and the attacker could still have gained access if they guessed correctly within the first 4 attempts, but with stronger password policies the likelihood of guessing this correctly is very low. If you wish to adopt stronger password policies I recommend following the most up-to-date [NIST Guidelines](https://pages.nist.gov/800-63-4/sp800-63b.html) to understand what makes a strong password, as this is subject to change.

I hope you found value in this blue team exercise. It was a rather trivial example, again showcasing a basic technique for gaining a foothold into an account or network. Nevertheless it was good for me to practice and I hope you followed along and learned something too.